[中文版 Google 代码规范](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#general-naming-rules)

一头文件

> 1 尽量减少.h中包含的头文件数量(头文件 #define 保护，要加上工程所在路径，)这会增加项目依赖，最好能用前置声明即可。头文件如何做到使用类Foo而无需访问类的定义？
> 1) 将数据成员类型声明为Foo*或Foo&；
> 2) 参数、返回值类型为Foo的函数只是声明（但不定义实现）；
> 3) 静态数据成员的类型可以被声明为Foo，因为静态数据成员的定义在类定义之外
>
> 通过上面三条，可以发现，在类内成员变量声明成指针类型更好，但是运行效率（引入指针降低一些效率）和可读性会降低，所以最好也不要这么做。类是 Foo 子类或者含有类型 Foo非静态数据成员时，就要在头文件中对相应 .h 进行包含了。
>
> 2 内联函数：只有 10 行时再声明定义成内敛。对于析构函数可以看情况是否内敛，有基类隐式成员时，析构函数执行慢，可以不定义在类内。还有一些函数包含了循环或者 switch 语句的函数不可以内敛，如果包含这两个的话，必须程序很少调用 swtich 和循环语句，否则不要内敛，虚函数和递归函数即使声明成内敛，也不会变成内联函数。
>
> 3 xxinl.h 文件：放置一些比较长多的内联函数用的，为了让 .h 文件更加简洁，可读，把一些多的内敛函数可以放到 xx.inl.h 文件中，方便阅读整合，这个文件里面可以是模板函数之类的定义。也需要进行 #ifdefine 的保护，这个文件可以是类的成员函数，只要外部某个.cc文件用了该类的这个成员函数，那么就需要包含对应的xxinl.h 文件！！！否则编译时就会出现错误。
>
> 4 函数参数顺序：输入在前，输出在后（非常量指针），基本上按照这个思路即可，对于类来说会有冲突，所以大体上进行遵循即可 
>
> 5 在对应 .cc 中头文件包含顺序，以 foo.cc 为例(路径名字，一定要是在 src 目录下的，这里src/dir2/foo2.h 这个顺序)：
> #include "dir2/foo2.h"//（优先位置，详情如下）
> C系统文件
> C++系统文件
> 其他库头文件
> 本项目内头文件
>
> 在 .h 中头文件包含顺序,
>
> C库、
>
> C++库、 
>
> 其他库的.h、
>
>  项目内的.h

二作用域

> 1 命名空间：具名命名空间将除文件包含、 全局标识的声明/定义以及类的前置声明外的整个源文件封装起来，不具名的命名空间可以代替 static。
>
> 可以在 （.cc文件、 .h）文件的函数、方法或类中，可以使用 using 声明即 using std::string，不要使用 using 指示 using namespace std; 这种不建议使用，会引发不必要的错误
>
> 2 嵌套类的使用，如果一个嵌套类B 仅仅被一个类 A 中使用，其他类不会使用，也就是该类不会作为接口，那么这个类 B 在那个类 A 中进行 前置声明，然后类的定义放在 .cc 文件中，这时可能会引发类 A 定义的成员函数会用到类 B 的对象，此时这些必须要放到 .cc 文件中，否则编译无法实例化类 B 对象。当然如果该类 B 不作为接口，那么就不要声明成 public。嵌套类符合局部使用原则，只是不能在其他头文件中前置声明嵌套类（已经测试了，在exe文件夹中use_result19.cc中）（这是因为嵌套类在被嵌套类中进行了前置声明，其他地方再用嵌套类指针时，就必须要包含被嵌套类头文件了，不能简单用前置声明），尽量不要public
>
> 3 非成员函数、静态成员函数、全局函数：不要污染全局作用域，因此使用命名空间，本类 .cc 文件使用，那么就直接定义到 .cc 的未命名空间中。如果外部使用的话，那么需要定义到本工程最外层命名空间内，这样外部调用会好些，但是也可以把这些函数封装到一个类，然后这些函数变成静态成员，但是容易在编译链接时出现依赖问题，所以最好不要这么做。
>
> 4 局部变量：哪里使用就要在哪里定义，对于类对象而言，循环里面最好不要定义对象，否则每次循环都会进行构造和析构，开销比较大，可以在循环外面进行定义。
>
> 5 全局变量：不要定义全局的类对象，因为全局类对象构造函数执行会出现一些 bug，全局类对象的初始化会在 main() 函数之前进行调用。可能会破坏构造函数某些暗含的假定（比如一些变量是需要 main 函数运行后才会知道的），如果真的想用，那就是用单例模式类对象。但是可以使用内置类型作为全局变量，全局字符串就用 c 风格的，也就是含有 \0 结束符，静态成员变量视做全局变量，也不能是 Class 对象（也就是说未命名命名空间内部的变量也不可以是类）。然*多线程*代码中非常数全局变量也是被禁止的。多线程会访问这些临界区，需要添加锁保护，永远不要使用函数返回值初始化全局变量。因为函数返回值是在 main 函数执行后才会执行的。

三类

> 1 构造函数：在初始化时，将有意义的成员初始化放到一个成员函数中专门做初始化操作，容易利用异常机制找到异常处，而且会解决构造函数中无法进行虚函数多态问题，然后定义一个该对象是否初始化完成的状态量。但是对于简单的初始化可以直接在构造函数中进行，
>
> 2  默认构造函数：new 之类的可能会自动使用默认构造函数，最好自己定义一下，编译器生成的默认构造函数只会默认初始化内置类型成员变量，调用类成员对象的默认构造函数，并不会调用其类对象成员的带参数的构造函数！
>
> 3 明确的构造函数：对单一的构造函数一定要加上 explicit，对于 Foo(const Foo&) 可以不用添加，其他 Foo(const string&) 之类需要添加
>
> 4 拷贝构造函数：仅仅在定义一个类，该类会被用作函数非引用参数等需要拷贝的情况下定义一个拷贝构造函数，其他情况要直接禁用拷贝和赋值，通过这种宏来明确，对于c++11 其实可以直接 =delete 即可！如果真的需要赋值和拷贝，那么就需要在头文件中说明，为什么需要！如果该类可以放在 stl 容器中，那么最好容器内部保存的是该类的指针形式（共享的智能指针最好，因为容器内部元素拷贝，仅仅拷贝指针！）.这里的 DISALLOW_... 只需要声明即可，不需要进行定义。
>
> ```c++
> 
> // 禁止使用拷贝构造函数和赋值操作的宏
> // 应在类的private:中使用
> #define DISALLOW_COPY_AND_ASSIGN(TypeName) \
> TypeName(const TypeName&); \
> void operator=(const TypeName&)
> // 下面就可以使用这个宏了，其实可以引用 c++11 新加入的 = delete，也就是可以把上面的宏进行改造（可以随意放在 public/private/protected 中），这里只是简单改造，默认是 c++11 可以作一个宏的分支选择
> #define DISALLOW_COPY_AND_ASSIGN(TypeName) \
> TypeName(const TypeName&) = delete; \
> void operator=(const TypeName&) = delete
> 
> class Foo {
> public:
> Foo(int f);
> ~Foo();
> private:
> DISALLOW_COPY_AND_ASSIGN(Foo);
> };
> ```
>
> 5 结构体和类：对于仿函数和 traits 技法之类的要用结构体 struct，还有比较简单的成员变量组合成的 struct（可以包含一个存取函数set get之类的成员函数），剩下的都用 class，如果不确定到底用不用 struct 那么此时就直接使用 class
>
> 6 继承：尽量减少继承的使用，除非有 is-a 这种关系才会用继承，其他都要用组合的方式，对于继承来说，我们一定仅仅用 public 继承，如果基类有虚函数，那么派生类对应函数后面一定要加上 override ，否则其他人读代码时不知道这个到底是不是虚函数。一般继承主要分为实现继承和接口继承，实现继承下，子类继承基类的实现代码，对于接口继承，子类继承方法名称，比如基类都是纯虚函数，如果要用私有继承，那么使用组合的方式更好！尽量少继承，多用组合！！！
>
> 7 多重继承：一般很少会用到多重实现继承，仅仅在最多一个基类中含有实现代码，其他类都是接口类时，会用多重实现继承。接口类的名称在后缀都会加上 Interface
>
> 8 接口：定义： 当一个类满足以下要求时，称之为纯接口（定义接口时，要以Interface 为结尾，这里要虽然非必须，但是自己要这么做），不能被实例化：
> 1) 只有纯虚函数（ "=0"）和静态函数（下文提到的析构函数除外）；
> 2) 没有非静态数据成员；
> 3) 没有定义任何构造函数。如果有，也不含参数，并且为protected；
> 4) 如果是子类，也只能继承满足上述条件并以Interface为后缀的类
>
> 9 操作符重载：虽然方便调用，但是缺点也很明显，比如一些其他人看代码时不理解内部开销（比如 = 操作符），查找操作符重载函数比较慢等等。所以除非必须，一般不要用操作符重载，比如perator<<(ostream&, const T&)）这个时候可以用，有些 stl 算法需要 == 操作符重载，如果 stl 算法中不需要必须操作符重载，那就用仿函数代替。如果真的使用了操作符重载，那么一定要在文档中进行说明
>
> 10 存取控制：成员变量私有化，提供存取函数 set_foo() foo()，这样的函数要是内联的。
>
> 11 声明次序：这里大体上按照 public ptotected private 这样的顺序来，可以按照stl 的那种格式，多个 public，按照功能划分，有些是内部使用的，有些是外部调用的，都要区分开。DISALLOW_COPY_AND_ASIGN() 宏 放在 private 后，在每一块中，可以按照顺序进行，typedefs enum 等等
>
> 12 编写短小函数：尽量将 40 行以上的函数分割成小块，使得阅读代码者更能理解代码含义。

五 其他 c++ 特性

> 1 引用参数：竟然建议不要使用非常量引用，但是最好还是要用非常量引用作为输入，输出可以是一个常量引用，必须要在注释中进行说明
>
> 2 函数重载：这个就按照重载定义即可，不需要按照它的要求
>
> 3 缺省参数：禁止使用缺省函数参数，但是一些特殊地方，还是要使用的。
>
> 4 变长数组和 alloca：在 c++11 中有专门的 allocator 分配器
>
> 5 友元：允许合理使用友元类及友元函数，友元打破了类的封装边界，一般如果仅仅一个类可以访问类的某个成员时，最好用友元，而不能用 public 公开成员
>
> 6 异常：google 建议不使用异常，其实有些不太合理，c++有标准的异常处理机制。异常是解决构造函数失败的唯一方案，所以在自己的项目中要大胆使用异常
>
> 7 运行是类型识别 RTTI:比较经典的在 c++primer 中讲解了使用。必要时可以使用。
>
> 8 类型转换：使用 c++ 的类型转换，不要用 c 的类型转换，一般常用的就是 static_cast<>()，可以用作父类到子类的转换，以及常见的c语言里面的转换，
>
> const_cast: 移除 const 的转换
>
> reinterpret_cast：指针类型和整形或其他指针间不安全的类型转换，必须自己知道在干嘛，否则不要用
>
> dynamic_cast:这个是 rtti 里面的，实际上 google_cartographer 里面就用了这个
>
> 9 流：日志方面用流，其他地方最终建议使用 printf 和 write / read。目标是使语言尽可能的小，而不是添加一些别人需要学习的新内容
>
> 10 前置自增和自减：推荐前置，因为后置自增自减会多一个拷贝步骤！
>
> 11 const 的使用：尽量使用 const，如果确定不会改变，那么就要直接使用 const
>
> 12 整型：如果你确定使用整型的32位，那么可以包含 <stdint.h>，这里面有 int16_t，int32_t，int64_t。在使用无符号数时，要定义有符号的变量，并且用 assert 来假定该变量大于0。
>
> 13 64 位下的可移植性：这个没有读明白，目前自己用不上
>
> 14 预处理宏：不要在 .h 中定义宏，使用 #define ，要在适当的地方用 #undef 进行取消，但是这些我们一般不会用到。尽量少的使用宏
>
> 15 0 和 NULL：整数用 0，实数用 0.0，指针用 NULL，字符串用 ''\0'
>
> 16 sizeof：使用 sizeof(varname)
>
> 17 Boost 库：只使用 boost 被认可的库

六 命名约定

> 1 通用命名规则：函数、变量、文件、应具有描述性，不要过度缩写，类型和变量名应该是名词，函数名可以用「命令性」动词
>
> 2 文件命名：全部小写，下划线连接。.cc .h 结尾。定义类是，文件名一般成对出现，如 foo_bar.h foo_bar.cc对应 FooBar。如果内联函数比较多，就把这些内联函数放入专门的内敛文件中，所以工程中一般会出现这几个文件：url_table.h url_table.cc url_table-inl.h这个可以写成url_table_inl.h
>
> 3 类型命名：大写字母开头，不包括下划线。所有类型命名（类、结构体、typedef、枚举）都使用相同约定，比如 UrlTable
>
> 4 变量命名：通常情况下，普通变量小写单词+下划线形式，类里面都是结尾加下划线 num_，struct 里面与普通变量命名一致。
>
> 5 常量和静态存储期变量命名：名称前面加k，例如 kDaysInAWeek，所有具有静态存储类型的变量 (例如静态变量或全局变量) 都应当以此方式命名。综合来说：就是所有 const /constexpr 变量（局部或全局，类内），以及 静态存储期变量（包括 static 标识的变量或者未命名的命名空间）的都要用 k 开头！！！！
>
> 6 函数命名：暴露给外部的函数可以用 AddTableEntry，存取函数以及类内，文件内的帮助函数用普通变量的命名规则 set_num_entries() 函数名和变量要对应上，类作用域和命名空间作用域常量也要用这个命名方法。
>
> 7 命名空间命名：小写字母命名，类似普通变量命名，一般依赖项目名称来命名，对于 internal 命名空间要加入文件名字，比如frobber.h使用websearch::index::frobber_internal 
>
> 8 枚举命名：这里采用宏的方式，因为 c++11 用枚举的时候可以用枚举名字::枚举值，这样就不会与一些宏名冲突了。
>
> enum GoogleChoice { GLOG_CHOICE, GFLAGS_CHOICE }; 
>
> 9 宏命名：大写加下划线；\#define MUST_USE_RESULT 
>
> 10 命名规则例外

七 注释

>1 注释风格：约定使用 //，在文件开头说明时，使用 /* */
>
>2 文件注释：文件开头按照下面方法进行注释
>
>```c++
>/*
> * CopyRight (c) 2019 gcj
> * File: queue.hpp
> * Project: algorithm
> * Author: gcj
> * Date: 2019/4/11
> * Description: queue simple implementation
> * License: see the LICENSE.txt file
> * github: https://github.com/saber/algorithm
> */
>```
>
>接着在后面就可以用 // 来注释，简单说明一些该文件的功能和用法（也可以布不写）。在 .h 文件中主要说明类的共呢个和用法，在 .cc 文件中说明实现细节或算法讨论。
>
>3 类注释：简单描述类的功能和用法，标注该类是否有多线程访问，可重入性！
>
>4 函数注释：声明处描述功能，定义处描述实现及某些实现的原因！输入和输出要及时标注
>
>> 如果函数分配了空间，需要由调用者释放，参数是否可以为 NULL，等等类似问题要进行标注提醒！
>
>5 变量注释：特定情况需要额外注释说明，所有全局变量需要进行说明含义及其用途
>
>6 实现注释：对于实现代码中一些难点进行说明
>
>7 标点，拼写和语法：这个基本没问题
>
>8 TODO 注释：对哪些临时的，短期的解决方案，或已经够好但并不完美的代码使用 TODO 注释。

八 格式

>1 行长度：不超过 80，有特殊情况，比如 URL 太长，这样可以超过 80 行的
>
>2 非 ASCII 字符：要用 UTF-8 格式的字符
>
>3 空格还是制表位：只使用空格，每次缩进 4 空格，可以设置编辑器的 TAB 键盘为软键盘代替 4 个空格.
>
>4 函数声明与定义：返回类型和函数名在同一行，参数可以放在同一行，或者都分开到每一行，注意空格和括号（大括号和小括号）的关系。这个可以看示例代码
>
>```c++
>void GoogleNorm::MemberFunc(const 值或引用(输入参数)，
>                            非 const 指针或引用) const {
>  
>}
>```
>
>1) 返回值总是和函数名在同一行；
>2) 左圆括号（open parenthesis）总是和函数名在同一行；
>3) 函数名和左圆括号间没有空格；
>4) 圆括号与参数间没有空格；
>5) 左大括号（open curly brace）总在最后一个参数同一行的末尾处；
>6) 右大括号（close curly brace）总是单独位于函数最后一行；
>7) 右圆括号（close parenthesis）和左大括号间总是有一个空格；
>8) 函数声明和实现处的所有形参名称必须保持一致；
>
>5 函数调用：尽量放在同一行，放不到同一行就从新起一行，比如下面这样
>
>```c++
>if (...) {
>    DoSomethingThatRequiresALongFunctionName(
>        very_long_argument1, // 4 space indent
>        argument2,
>        argument3,
>        argument4);
>}
>bool retval = DoSomething(argument1,
>                          argument2,
>                          argument3,
>                          argument4);
>```
>
>6 条件语句：必须包含大括号，注意里面的空格关系
>
>```c++
>if (condition) {  
> 
>} else { 
>...
>}
>```
>
>7 循环和开关选择语句
>
>```c++
>switch (var) {
>    case 0: {  
>        break;
>	}
>    case 1: {
>     
>    }
>    default: {
>    	assert(false);
>    }
>}
>```
>
>8 指针和引用表达式：char *u; char &u; 保持符号变量紧紧挨着
>
>9 布尔表达式：注意分行表达
>
>```c++
>if (this_one_thing > this_other_thing &&
>    a_third_thing == a_fourth_thing &&
>    yet_another & last_one) {
>...
>}
>```
>
>10 函数返回值   
>
>return (some_long_condition &&
>
>​      		another_condition);
>
>11 变量及数组初始化：
>
>```c++
>int x = 3;
>int x(3);
>string name("Some Name");
>string name = "Some Name";
>```
>
>12 预处理指令：不要缩进，从行首开始（无论该指令是否位于缩进代码块中）
>
>13 类格式：参考第六章
>
>14 构造函数初始化列表
>
>```c++
>MyClass::MyClass(int var)
>    : some_var_(var), // 4 space indent
>      some_other_var_(var + 1) { // lined up
>    ...
>    DoSomething();
>...
>}
>MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) {
>```
>
>15 命名空间格式化：命名空间不缩进，不额外缩进层次
>
>```c++
>namespace {
>void foo() { // Correct. No extra indentation within namespace.
>...
>}
>} // namespace
>```
>
>16 水平留白：多余的空格要去掉
>
>17 垂直留白：函数头尾不要由空行

九 规则之例外

>1 现有不统一代码：修改使用其他人代码时，可以局部遵从原作者的代码风格
>
>2 Windows 代码：遵从 google 规范即可；多使用 C++ 自有的类型；使用 MSVC 时，把 warning 当作 errors 处理；不要使用 #pragma once 作为包含保护，使用 c++ 标准包含保护。#include <prj_name/public/tools.h>；除非万不得已，不要使用不标准的扩展，比如 #pragma,__declspec
>
>